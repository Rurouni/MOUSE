<#@ Assembly Name="System.Core.dll" #>
<#@ Assembly Name="System.Xml.dll" #>
<#@ Assembly Name="System.Xml.Linq.dll" #>
<#@ Assembly Name="System.Runtime.Serialization.dll" #>
<#@ Assembly Name="$(SolutionDir)Bin\MOUSE.Core.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Runtime.Serialization" #>
<#@ import namespace="System.CodeDom" #>
<#@ import namespace="Microsoft.CSharp" #>
<#@ import namespace="MOUSE.Core" #>

<#@ include file="MessagesGeneration.ttinclude" #>
<#@ include file="POCOSerialization.ttinclude" #>

<#+  
void GenerateProtocol(IEnumerable<Assembly> assemblies)
{ #>
using System;
using System.Collections;
using System.IO;
using System.Collections.Generic;
using System.Runtime.Serialization;
using MOUSE.Core;
using UnityClient;

namespace Protocol.Generated
{
<#+
	foreach (var asm in assemblies)
		foreach (var type in asm.GetTypes().Where(x => x.ContainsAttribute<NetContractAttribute>()))
			GenerateCoroutineContract(type);

	foreach (var asm in assemblies)
		foreach (var type in asm.GetTypes().Where(x => x.ContainsAttribute<NetContractAttribute>()))
		   GenerateCoroutineProxy(type);

	foreach (var asm in assemblies)
		foreach (var type in asm.GetTypes().Where(x => x.ContainsAttribute<NetContractAttribute>()))
			GenerateMessages(type);
	foreach (var asm in assemblies)
		foreach (var type in asm.GetTypes().Where(x => x.ContainsAttribute<DataContractAttribute>()))
			GenerateDTO(type);

	foreach (var asm in assemblies)
		foreach (var type in asm.GetTypes().Where(x => x.ContainsAttribute<DataContractAttribute>()))
			GenerateDTOSerialization(type);#>
}
<#+
}
void GenerateCoroutineContract(Type contractType)
{
	var attr = contractType.GetAttribute<NetContractAttribute>();
#>
	[NetContract]
	public interface <#= contractType.Name #>
	{
<#+	foreach (MethodInfo method in contractType.GetMethods())
	{
		WriteCoroutineInterfaceDef(method);	
	} #>
	}
<#+
}

void GenerateDTO(Type dtoType)
{
	if(dtoType.IsEnum)
	{
		var cs = new CSharpCodeProvider();#>
	
	public enum <#= dtoType.Name #> : <#= cs.GetTypeOutput(new CodeTypeReference(Enum.GetUnderlyingType(dtoType)))#>
	{
<#+	foreach (FieldInfo fi in dtoType.GetFields(BindingFlags.Public | BindingFlags.Static))
	{ #>
		<#= fi.Name + " = " + fi.GetRawConstantValue() #>,
<#+ } #>
	}
<#+	}
	else
	{ #>
	
	public class <#= dtoType.Name #>
	{
<#+	foreach (FieldInfo field in dtoType.GetFields())
	{ #>
		public <#= TypeToString(field.FieldType) + " " + field.Name #>;
<#+ } #>
	}
<#+
	}
}

void GenerateCoroutineProxy(Type contractType)
{ #>
	[NetProxy(ContractTypeId = <#= Misc.GenerateHash(contractType.Name) #>, ContractType = typeof(<#= contractType.Name #>))]
	public sealed class <#= contractType.Name + "Proxy" #> : NodeServiceProxy, <#= contractType.Name #>
	{
<#+	var attr = contractType.GetAttribute<NetContractAttribute>();
	foreach (MethodInfo method in contractType.GetMethods())
	{
		WriteCoroutineMethodDef(method);	#>
		{
		<#+ WriteMethodBody(method, contractType); #>
		}
<#+ 	string replyMsgType;
		if(method.ReturnType == typeof(void))
			replyMsgType = "null";
		else 
			replyMsgType = "typeof("+contractType.Name + method.Name + "Reply)";	#>
		[NetOperationDispatcher(RequestMessage = typeof(<#= contractType.Name + method.Name + "Request" #>), ReplyMessage = <#= replyMsgType #>)]
		public static void <#= method.Name #>(IMessageFactory msgFactory, object target, Message input)
		{
		<#+ WriteDispatcherBody(method, contractType); #>
		}
<#+		
	}	#>
	}
<#+
}
void WriteCoroutineInterfaceDef(MethodInfo method)
{
	var paramsText = new StringBuilder();
	var paramArr = method.GetParameters();
	for (int i = 0; i < paramArr.Length; i++)
	{
		if(i!=0)
			paramsText.Append(", ");
		paramsText.Append(TypeToString(paramArr[i].ParameterType)+" "+ paramArr[i].Name);
	}
	if(method.ReturnType == typeof(void))
	{ #>
		void <#= method.Name #> ( <#= paramsText #> );
<#+ }
	else
	{
		if(paramArr.Length > 0)
			paramsText.Append(", ");
		#>
		IEnumerable <#= method.Name #> ( <#= paramsText #> OperationReply< <#= TypeToString(method.ReturnType) #> > reply);
<#+ }
}
void WriteCoroutineMethodDef(MethodInfo method)
{
	var paramsText = new StringBuilder();
	var paramArr = method.GetParameters();
	for (int i = 0; i < paramArr.Length; i++)
	{
		if(i!=0)
			paramsText.Append(", ");
		paramsText.Append(TypeToString(paramArr[i].ParameterType)+" "+ paramArr[i].Name);
	}
	if(method.ReturnType == typeof(void))
	{ #>
		public void <#= method.Name #> ( <#= paramsText #> )
<#+ }
	else
	{
		if(paramArr.Length > 0)
			paramsText.Append(", ");
		#>
		public IEnumerable <#= method.Name #> ( <#= paramsText #> OperationReply< <#= TypeToString(method.ReturnType) #> > replyChannel)
<#+ }
}

void WriteMethodBody(MethodInfo method, Type contractType)
{	#>
	//var request = MessageFactory.New< <#= contractType.Name + method.Name + "Request" #> >();
			var request = new <#= contractType.Name + method.Name + "Request" #>();
<#+ foreach(var par in method.GetParameters())
	{	#>
			request.<#= par.Name +"="+ par.Name #>;
<#+
	}
	if(method.ReturnType == typeof(void))
	{	#>
			ExecuteOneWayServiceOperation(request);
			//MessageFactory.Free(request);
<#+ }
	else
	{	#>
			var msgReply = new OperationReply<Message>();
			foreach(object obj in ExecuteServiceOperation(request, msgReply))
				 yield return obj;
			if(msgReply.IsValid)
				replyChannel.SetReply( ((<#= contractType.Name + method.Name + "Reply" #>)msgReply.Reply).RetVal, null);
			else
				replyChannel.SetReply(default(<#=  TypeToString(method.ReturnType) #>), msgReply.Error);
			//MessageFactory.Free(reply);
			//MessageFactory.Free(request);
<#+ }
}

void WriteDispatcherBody(MethodInfo method, Type contractType)
{
	var paramsText = new StringBuilder();
	var paramArr = method.GetParameters();
	for (int i = 0; i < paramArr.Length; i++)
	{
		if(i!=0)
			paramsText.Append(", ");
		paramsText.Append("msg."+paramArr[i].Name);
	}
	#>
	var msg = (<#= contractType.Name + method.Name+ "Request" #>)input;
<#+ 
	if(method.ReturnType == typeof(void))
	{	#>
			((<#= contractType.Name #>)target).<#= method.Name #>(<#= paramsText #>);
<#+ }
	else
	{	#>
			throw new NotSupportedException();
<#+ }
}
#>
