<#+  
void GenerateSerialization(Type type) 
{
#>	
    public static class <#= type.Name+"Serializer" #>	
    {
        public static void Serialize(<#= type.FullName #> x, NativeWriter w)
        {
			if(x == null)
			{
				w.Write<#= GetWriteSuffix(typeof(bool)) #>(false);
				return;
			}
			w.Write<#= GetWriteSuffix(typeof(bool)) #>(true);
<#+ foreach (var field in type.GetFields().Where(x => x.ContainsAttribute<DataMemberAttribute>()))
        WriteComplex(field.FieldType, "x."+field.Name); #>
        }
        
        public static <#= type.FullName #> Deserialize(NativeReader r)
        {
			{
				bool isNotNull = r.Read<#= GetReadSuffix(typeof(bool)) #>();
				if(!isNotNull)
					return null;
			}
            var ret = new <#= type.FullName #>();
<#+ foreach (var field in type.GetFields().Where(x => x.ContainsAttribute<DataMemberAttribute>()))
        ReadComplex(field.FieldType, "ret."+field.Name); #>
            return ret;
        }
    }
<#+  
}
void WriteComplex(Type type, string name)
{
    if(IsAtomic(type))
        WriteAtomic(type, name);
    else if(IsArray(type))
        WriteArray(type, name);
    else 
        WriteExternal(type, name);
}
void WriteExternal(Type type, string name)
{ #>
    		<#= type.Name+"Serializer" #>.Serialize(<#= name #>, w);
<#+ 
}
void WriteAtomic(Type type, string name)
{ #>
            w.Write<#= GetWriteSuffix(type) #>(<#= name #>);
<#+
}
void WriteArray(Type type, string name)
{ #>
			if(<#= name #> != null)
			{
				w.Write<#= GetWriteSuffix(typeof(bool)) #>(true);
				w.Write<#= GetWriteSuffix(typeof(int)) #>((int)<#= name #>.Count);
				foreach(var element in <#= name #>)
		<#+ WriteComplex(type.GetGenericArguments()[0], "element");#>
			}
			else
				w.Write<#= GetWriteSuffix(typeof(bool)) #>(false);
<#+
}
void ReadComplex(Type type, string name)
{
    if(IsAtomic(type))
        ReadAtomic(type, name);
    else if(IsArray(type))
        ReadArray(type, name);
    else 
        ReadExternal(type, name);
}
void ReadExternal(Type type, string name)
{ #>
    		<#= name #> = <#= type.Name+"Serializer" #>.Deserialize(r);
<#+ 
}
void ReadAtomic(Type type, string name)
{ #>
            <#= name #> = r.Read<#= GetReadSuffix(type) #>();
<#+
}
void ReadArray(Type type, string name)
{ #>
            {
				bool isNotNull = r.Read<#= GetReadSuffix(typeof(bool)) #>();
				if(!isNotNull)
					<#= name #> = null;
				else
				{
					int lenght = r.Read<#= GetReadSuffix(typeof(int)) #>();
					var list = new List< <#= type.GetGenericArguments()[0] #> >(lenght);
					for(int i = 0; i < lenght; i++)
					{
			<#+ ReadComplex(type.GetGenericArguments()[0], "var x"); #>
						list.Add(x);
					}
					<#= name #> = list;
				}
            }
<#+ 
}
string TypeToString(Type type)
{
    using (var p = new CSharpCodeProvider())
    {
        var r = new CodeTypeReference(type);
        return p.GetTypeOutput(r);
    }            
}
bool IsAtomic(Type type)
{
    return type == typeof(byte)
    ||type == typeof(short)
    ||type == typeof(ushort)
    ||type == typeof(int)
    ||type == typeof(uint)
    ||type == typeof(long)
    ||type == typeof(ulong)
    ||type == typeof(bool)
    ||type == typeof(string);
}
bool IsArray(Type type)
{
    return type.IsGenericType && type.GetGenericTypeDefinition() == typeof(List<>);
}
string GetReadSuffix(Type type)
{
    if(type == typeof(byte))
        return "Byte";
    if (type == typeof(bool))
	    return "Boolean";
    if(type == typeof(short))
        return "Int16";
    if(type == typeof(ushort))
        return "UInt16";
    if(type == typeof(int))
        return "Int32";
    if(type == typeof(uint))
        return "UInt32";
    if(type == typeof(long))
        return "Int64";
    if(type == typeof(ulong))
        return "UInt64";
    if(type == typeof(string))
        return "Unicode";
    
    throw new Exception("Cannot map type:"+type);
}
string GetWriteSuffix(Type type)
{
    if(type == typeof(byte))
        return "";
    if (type == typeof(bool))
	    return "";
    if(type == typeof(short))
        return "";
    if(type == typeof(ushort))
        return "";
    if(type == typeof(int))
        return "";
    if(type == typeof(uint))
        return "";
    if(type == typeof(long))
        return "";
    if(type == typeof(ulong))
        return "";
    if(type == typeof(string))
        return "Unicode";
    
    throw new Exception("Cannot map type:"+type);
}
#>