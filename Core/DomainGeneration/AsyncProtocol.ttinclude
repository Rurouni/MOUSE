<#@ Assembly Name="System.Core.dll" #>
<#@ Assembly Name="System.Xml.dll" #>
<#@ Assembly Name="System.Xml.Linq.dll" #>
<#@ Assembly Name="System.Runtime.Serialization.dll" #>
<#@ Assembly Name="$(SolutionDir)Bin\MOUSE.Core.dll" #>
<#@ Assembly Name="$(SolutionDir)Bin\MOUSE.Core.Portable.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Runtime.Serialization" #>
<#@ import namespace="System.Threading.Tasks" #>
<#@ import namespace="System.CodeDom" #>
<#@ import namespace="Microsoft.CSharp" #>
<#@ import namespace="MOUSE.Core" #>

<#@ include file="MessagesGeneration.ttinclude" #>
<#@ include file="POCOSerialization.ttinclude" #>

<#+  
void GenerateAsyncProtocol(string namespaceName, IEnumerable<Assembly> assemblies)
{ #>
using MOUSE.Core;
using System;
using System.IO;
using System.Collections.Generic;
using System.Threading.Tasks;
using System.Runtime.Serialization;

#pragma warning disable 1998

namespace <#= namespaceName #>
{
<#+
	List<Type> contractTypes = new List<Type>();
	foreach (var asm in assemblies)
		foreach (var type in asm.GetTypes().Where(x => x.ContainsAttribute<NetContractAttribute>()))
			contractTypes.Add(type);

	foreach (var type in contractTypes)
		GenerateAsyncContract(type);

	foreach (var type in contractTypes)
		GenerateAsyncProxy(type);

	List<string> generatedMessages = new List<string>();
	foreach (var type in contractTypes)
		GenerateMessages(type, generatedMessages);

	List<Type> dtoTypes = new List<Type>();
	foreach (var asm in assemblies)
		foreach (var type in asm.GetTypes().Where(x => x.ContainsAttribute<DataContractAttribute>()))
			dtoTypes.Add(type);

	foreach (var type in dtoTypes)
		GenerateDTO(type);

	foreach (var type in dtoTypes)
		GenerateDTOSerialization(type);

	foreach(var type in AppDomain.CurrentDomain.GetAssemblies().SelectMany(x=>x.GetTypes()).Where(x => typeof(Message).IsAssignableFrom(x) && !x.IsAbstract ))
		generatedMessages.Add(type.FullName);#>
	
	public static class ProtocolDescription
	{
		private static List<Message> s_messages;
		private static List<NetProxy> s_proxies;

		static ProtocolDescription()
		{
			s_messages  = new List<Message>();
<#+ foreach(var msgName in generatedMessages)
	{ #>
			s_messages.Add(new <#= msgName #>());
<#+ } #>

			s_proxies = new List<NetProxy>();
<#+ foreach (var type in contractTypes)
	{ #>
			s_proxies.Add(new <#= type.Name +"Proxy" #>());
<#+ } #>
		}

		public static List<Message> GetAllMessages()
		{
			return s_messages;
		}

		public static List<NetProxy> GetAllProxies()
		{
			return s_proxies;
		}
	}
}
<#+
}
void GenerateAsyncContract(Type contractType)
{
	var attr = contractType.GetAttribute<NetContractAttribute>();
#>

	[NetContract(AllowExternalConnections = <#= attr.AllowExternalConnections.ToString().ToLower() #>, IsPrimary = <#= attr.IsPrimary.ToString().ToLower() #>)]
	public interface <#= contractType.Name #>
	{
<#+	foreach (MethodInfo method in contractType.GetMethods())
	{
		WriteAsyncInterfaceDef(method);	
	} #>
	}
<#+
}

void GenerateAsyncProxy(Type contractType)
{ #>
	[NetProxy(ContractTypeId = <#= Misc.GenerateHash(contractType.Name) #>, ContractType = typeof(<#= contractType.Name #>))]
	public sealed class <#= contractType.Name + "Proxy" #> : NetProxy, <#= contractType.Name #>
	{
<#+	var attr = contractType.GetAttribute<NetContractAttribute>();
	foreach (MethodInfo method in contractType.GetMethods())
	{
		WriteAsyncMethodDef(method);	#>
		{
		<#+ WriteMethodBody(method, contractType); #>
		}
<#+ 	string replyMsgType;
		if(method.ReturnType == typeof(void))
			replyMsgType = "null";
		else 
			replyMsgType = "typeof("+contractType.Name + method.Name + "Reply)";	#>
		[NetOperationDispatcher(RequestMessage = typeof(<#= contractType.Name + method.Name + "Request" #>), ReplyMessage = <#= replyMsgType #>)]
		public static async Task<Message> <#= method.Name #>(IMessageFactory msgFactory, object target, Message input)
		{
		<#+ WriteDispatcherBody(method, contractType); #>
		}
<#+		
	}	#>
	}
<#+
}
void WriteAsyncInterfaceDef(MethodInfo method)
{
	var paramsText = new StringBuilder();
	var paramArr = method.GetParameters();
	for (int i = 0; i < paramArr.Length; i++)
	{
		if(i!=0)
			paramsText.Append(", ");
		paramsText.Append(TypeToString(paramArr[i].ParameterType)+" "+ paramArr[i].Name);
	}
	if(method.ReturnType == typeof(void))
	{ #>
		void <#= method.Name #> ( <#= paramsText #> );
<#+ }
	else
	{
		#>
		Task< <#= TypeToString(method.ReturnType) #> > <#= method.Name #> ( <#= paramsText #> );
<#+ }
}
void WriteAsyncMethodDef(MethodInfo method)
{
	var paramsText = new StringBuilder();
	var paramArr = method.GetParameters();
	for (int i = 0; i < paramArr.Length; i++)
	{
		if(i!=0)
			paramsText.Append(", ");
		paramsText.Append(TypeToString(paramArr[i].ParameterType)+" "+ paramArr[i].Name);
	}
	if(method.ReturnType == typeof(void))
	{ #>
		public void <#= method.Name #> ( <#= paramsText #> )
<#+ }
	else
	{
		#>
		public async Task< <#= TypeToString(method.ReturnType) #> > <#= method.Name #> ( <#= paramsText #> )
<#+ }
}

void WriteMethodBody(MethodInfo method, Type contractType)
{	#>
	var request = MessageFactory.New< <#= contractType.Name + method.Name + "Request" #> >();
<#+ foreach(var par in method.GetParameters())
	{	#>
			request.<#= par.Name +"="+ par.Name #>;
<#+
	}
	if(method.ReturnType == typeof(void))
	{	#>
			ExecuteOneWayOperation(request);
<#+ }
	else
	{	#>
			Message reply = await ExecuteOperation(request);
			var ret = ((<#= contractType.Name + method.Name + "Reply" #>)reply).RetVal;
			MessageFactory.Free(reply);
			return ret;
<#+ }
}

void WriteDispatcherBody(MethodInfo method, Type contractType)
{
	var paramsText = new StringBuilder();
	var paramArr = method.GetParameters();
	for (int i = 0; i < paramArr.Length; i++)
	{
		if(i!=0)
			paramsText.Append(", ");
		paramsText.Append("msg."+paramArr[i].Name);
	}
	#>
	var msg = (<#= contractType.Name + method.Name+ "Request" #>)input;
<#+ 
	if(method.ReturnType == typeof(void))
	{	#>
			((<#= contractType.Name #>)target).<#= method.Name #>(<#= paramsText #>);
			return null;
<#+ }
	else
	{	#>
			var retVal = await ((<#= contractType.Name #>)target).<#= method.Name #>(<#= paramsText #>);
			var retMsg = msgFactory.New<<#= contractType.Name + method.Name+ "Reply" #>>();
			retMsg.RetVal = retVal;
			return retMsg;
<#+ }
}
#>
